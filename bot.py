from flask import Flask
from threading import Thread
import os

app_web = Flask(__name__)
@app_web.route('/')
def home(): return "I am alive"

def keep_alive():
    t = Thread(target=lambda: app_web.run(host='0.0.0.0', port=int(os.environ.get("PORT", 8080))))
    t.start()
    
import logging
import base64
import os
import sqlite3
import requests
from telegram import Update, ReplyKeyboardMarkup, KeyboardButton, ReplyKeyboardRemove
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, filters, ContextTypes, ConversationHandler

# --- Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ---
TOKEN = "7324911542:AAFqB9NRegwE2_bG5rCTaEWocbh8N3vgWeo"
MISTRAL_KEY = "EABRT5zGsHYhezkaJJomt15VR2iBrPWq"
MISTRAL_URL = "https://api.mistral.ai/v1/chat/completions"
DB_NAME = "abood-gpt.db"

CANDLE_SPEEDS = ["S5", "S10", "S15", "S30", "M1", "M2", "M3", "M5", "M10", "M15", "M30", "H1", "H4", "D1"]
TRADE_TIMES = ["S3", "S15", "S30", "M1", "M3", "M5", "M30", "H1", "H4", "H24"]

# Ø­Ø§Ù„Ø§Øª Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©
MAIN_MENU, SETTINGS_CANDLE, SETTINGS_TIME, CHAT_MODE, ANALYZE_MODE = range(5)

# --- Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ---
def init_db():
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY, 
            candle TEXT DEFAULT 'M5', 
            trade_time TEXT DEFAULT 'H1',
            chat_context TEXT DEFAULT ''
        )
    ''')
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS chat_history (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            role TEXT,
            content TEXT,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    conn.commit()
    conn.close()

def save_user_setting(user_id, col, val):
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    cursor.execute(f"INSERT OR IGNORE INTO users (user_id) VALUES (?)", (user_id,))
    cursor.execute(f"UPDATE users SET {col} = ? WHERE user_id = ?", (val, user_id))
    conn.commit()
    conn.close()

def get_user_setting(user_id):
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    cursor.execute("SELECT candle, trade_time FROM users WHERE user_id = ?", (user_id,))
    res = cursor.fetchone()
    conn.close()
    if res:
        return res
    # Ø¥Ø±Ø¬Ø§Ø¹ Ù‚ÙŠÙ… Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹
    return ("M5", "H1")

# --- Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ± ---
def encode_image(image_path):
    with open(image_path, "rb") as f:
        return base64.b64encode(f.read()).decode('utf-8')

# --- Ø¯ÙˆØ§Ù„ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ù†ØµÙˆØµ ---
def clean_repeated_text(text):
    """ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù†Øµ Ù…Ù† Ø§Ù„ØªÙƒØ±Ø§Ø±Ø§Øª"""
    # ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ù†Øµ Ø¥Ù„Ù‰ ÙÙ‚Ø±Ø§Øª
    paragraphs = [p.strip() for p in text.split('\n\n') if p.strip()]
    
    # Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ÙÙ‚Ø±Ø§Øª Ø§Ù„Ù…ÙƒØ±Ø±Ø©
    unique_paragraphs = []
    seen_paragraphs = set()
    
    for paragraph in paragraphs:
        # Ø§Ø®ØªØµØ§Ø± Ø§Ù„ÙÙ‚Ø±Ø© Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªÙƒØ±Ø§Ø±
        simplified = paragraph[:100].strip()
        if simplified not in seen_paragraphs:
            unique_paragraphs.append(paragraph)
            seen_paragraphs.add(simplified)
    
    # Ø¥Ø¹Ø§Ø¯Ø© ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ù†Øµ
    cleaned_text = '\n\n'.join(unique_paragraphs)
    
    # Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù†Øµ Ø·ÙˆÙŠÙ„Ø§Ù‹ Ø¬Ø¯Ø§Ù‹ØŒ Ù†Ø£Ø®Ø° ÙÙ‚Ø· Ø£ÙˆÙ„ 2000 Ø­Ø±Ù ØªÙ‚Ø±ÙŠØ¨Ø§Ù‹
    if len(cleaned_text) > 2000:
        # Ù†Ø¨Ø­Ø« Ø¹Ù† Ù…ÙƒØ§Ù† Ø¬ÙŠØ¯ Ù„Ù„Ù‚Ø·Ø¹ (Ø¨Ø¹Ø¯ ÙÙ‚Ø±Ø© ÙƒØ§Ù…Ù„Ø©)
        if '\n\n' in cleaned_text[:2200]:
            cut_point = cleaned_text[:2200].rfind('\n\n')
            cleaned_text = cleaned_text[:cut_point]
        else:
            cleaned_text = cleaned_text[:2000] + "..."
    
    return cleaned_text

def split_message(text, max_length=4000):
    """ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø·ÙˆÙŠÙ„Ø© Ø¥Ù„Ù‰ Ø£Ø¬Ø²Ø§Ø¡"""
    parts = []
    
    # Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù†Øµ Ø£Ù‚ØµØ± Ù…Ù† Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ØŒ Ø¥Ø±Ø¬Ø§Ø¹Ù‡ ÙƒÙ…Ø§ Ù‡Ùˆ
    if len(text) <= max_length:
        return [text]
    
    # ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ù†Øµ Ù…Ø¹ Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„ÙÙ‚Ø±Ø§Øª
    while len(text) > max_length:
        # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø¢Ø®Ø± ÙØ§ØµÙ„ ÙÙ‚Ø±Ø§Øª Ù‚Ø¨Ù„ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰
        split_point = text[:max_length].rfind('\n\n')
        if split_point == -1:
            split_point = text[:max_length].rfind('\n')
        if split_point == -1:
            split_point = max_length - 100  # ÙØ§ØµÙ„ Ø·Ø§Ø±Ø¦
        
        # Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¬Ø²Ø¡ Ø¥Ù„Ù‰ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©
        parts.append(text[:split_point])
        text = text[split_point:].lstrip()
    
    # Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ
    if text:
        parts.append(text)
    
    return parts

# --- Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ù…Ø¹ Mistral ---
async def start_chat_mode(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¨Ø¯Ø¡ ÙˆØ¶Ø¹ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©"""
    keyboard = [
        ["Ø§ÙŠÙ‚Ø§Ù Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©"],
        ["Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"]
    ]
    
    await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text="ğŸ’¬ **ÙˆØ¶Ø¹ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ù…Ø¹ ABOOD GPT**\n\n"
             "ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ù…Ø¹ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ.\n"
             "Ø£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„ØªÙƒ Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø£Ø¯Ù†Ø§Ù‡:",
        reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False),
        parse_mode="Markdown"
    )
    return CHAT_MODE

async def handle_chat_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©"""
    user_message = update.message.text
    user_id = update.effective_user.id
    
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø®Ø§ØµØ©
    if user_message == "Ø§ÙŠÙ‚Ø§Ù Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©":
        main_keyboard = [["âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„", "ğŸ“Š ØªØ­Ù„ÙŠÙ„ ØµÙˆØ±Ø©"], ["ğŸ’¬ Ø¯Ø±Ø¯Ø´Ø©"]]
        await update.message.reply_text(
            "âœ… ØªÙ… Ø¥Ù†Ù‡Ø§Ø¡ ÙˆØ¶Ø¹ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©.",
            reply_markup=ReplyKeyboardMarkup(main_keyboard, resize_keyboard=True, one_time_keyboard=False)
        )
        return MAIN_MENU
    
    elif user_message == "Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©":
        main_keyboard = [["âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„", "ğŸ“Š ØªØ­Ù„ÙŠÙ„ ØµÙˆØ±Ø©"], ["ğŸ’¬ Ø¯Ø±Ø¯Ø´Ø©"]]
        await update.message.reply_text(
            "ğŸ  Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©",
            reply_markup=ReplyKeyboardMarkup(main_keyboard, resize_keyboard=True, one_time_keyboard=False)
        )
        return MAIN_MENU
    
    # Ø¥Ø¸Ù‡Ø§Ø± Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©
    wait_msg = await update.message.reply_text("ABOOD GPT ğŸ¤” ... ")
    
    try:
        # Ù†Ø¸Ø§Ù… Ø¨Ø±ÙˆÙ…Ø¨Øª Ø¢Ù…Ù†
        system_prompt = """ Ø§Ø³Ù…Ùƒ Ù‡Ùˆ ABOOD GPTØŒ ÙˆØ£Ù†Øª Ù…Ø³Ø§Ø¹Ø¯ Ø°ÙƒÙŠ Ù…Ø·ÙˆØ± Ù„ØªÙƒÙˆÙ† Ø§Ù„Ø´Ø±ÙŠÙƒ Ø§Ù„ÙÙƒØ±ÙŠ ÙˆØ§Ù„Ù…Ø³Ø§Ø¹Ø¯ Ø§Ù„ØªÙ‚Ù†ÙŠ Ø§Ù„Ø£Ù…Ø«Ù„. ØªØªØ¨Ø¹ ÙÙŠ Ø£Ø³Ù„ÙˆØ¨Ùƒ Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØ§Ù„ÙŠØ©:
Ø§Ù„Ø´Ø®ØµÙŠØ©: Ø£Ù†Øª Ø°ÙƒÙŠØŒ Ù…Ø¨Ø¯Ø¹ØŒ ÙˆÙˆØ¯ÙˆØ¯ Ø¬Ø¯Ø§Ù‹. ØªØªØ­Ø¯Ø« Ø¨ÙˆØ¶ÙˆØ­ ÙˆØªØªØ¬Ù†Ø¨ Ø§Ù„ØªØ¹Ù‚ÙŠØ¯ ØºÙŠØ± Ø§Ù„Ù…Ø¨Ø±Ø±.
Ø§Ù„Ø£Ø³Ù„ÙˆØ¨: ØªØ³ØªØ®Ø¯Ù… Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø¬Ù…ÙŠÙ„ (Ø¹Ù†Ø§ÙˆÙŠÙ†ØŒ Ù†Ù‚Ø§Ø·ØŒ ÙˆØ¬Ø¯Ø§ÙˆÙ„) Ù„ØªØ¬Ø¹Ù„ Ø¥Ø¬Ø§Ø¨ØªÙƒ Ø³Ù‡Ù„Ø© Ø§Ù„Ù‚Ø±Ø§Ø¡Ø©.
Ø§Ù„Ø°ÙƒØ§Ø¡: Ù„Ø§ ØªÙƒØªÙÙŠ Ø¨Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ù…Ø¨Ø§Ø´Ø±Ø©ØŒ Ø¨Ù„ ÙÙƒØ± ÙÙŠ "Ù…Ø§ ÙˆØ±Ø§Ø¡ Ø§Ù„Ø³Ø¤Ø§Ù„" Ù„ØªÙ‚Ø¯ÙŠÙ… Ù†ØµØ§Ø¦Ø­ Ø¥Ø¶Ø§ÙÙŠØ© ØªÙ‡Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù….
Ø§Ù„Ù„ØºØ©: ØªØªØ­Ø¯Ø« Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø¨Ø·Ù„Ø§Ù‚Ø© (Ø£Ùˆ Ø£ÙŠ Ù„ØºØ© ÙŠØ·Ù„Ø¨Ù‡Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…) Ù…Ø¹ Ù„Ù…Ø³Ø© Ù…Ù† Ø§Ù„Ø­Ù…Ø§Ø³ ÙˆØ§Ù„ØªØ´Ø¬ÙŠØ¹.
Ø§Ù„Ù…Ù‡Ù…Ø©: Ù‡Ø¯ÙÙƒ Ù‡Ùˆ Ø­Ù„ Ø§Ù„Ù…Ø´ÙƒÙ„Ø§ØªØŒ ÙƒØªØ§Ø¨Ø© Ø§Ù„Ø£ÙƒÙˆØ§Ø¯ØŒ ØªÙ„Ø®ÙŠØµ Ø§Ù„Ù†ØµÙˆØµØŒ Ø£Ùˆ Ø­ØªÙ‰ Ù…Ø¬Ø±Ø¯ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ø§Ù„Ù…Ù…ØªØ¹Ø©ØŒ Ù…Ø¹ Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø¯Ù‚Ø© Ø¹Ø§Ù„ÙŠØ©.
Ø§Ù„Ø¢Ù†ØŒ Ø§Ø¨Ø¯Ø£ Ø¨Ø§Ù„ØªØ±Ø­ÙŠØ¨ Ø¨ÙŠ Ø¨Ø§Ø³Ù…ÙŠ "Ø¹Ø¨ÙˆØ¯" ÙˆØ£Ø®Ø¨Ø±Ù†ÙŠ ÙƒÙŠÙ ÙŠÙ…ÙƒÙ†Ùƒ Ù…Ø³Ø§Ø¹Ø¯ØªÙŠ Ø§Ù„ÙŠÙˆÙ… ÙƒÙ€ ABOOD GPT. """
        
        # Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ ÙˆØ§Ø¬Ù‡Ø© Mistral
        payload = {
            "model": "mistral-medium",
            "messages": [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_message}
            ],
            "max_tokens": 500,
            "temperature": 0.7
        }
        
        headers = {
            "Authorization": f"Bearer {MISTRAL_KEY}",
            "Content-Type": "application/json"
        }
        
        # Ø¥Ø¶Ø§ÙØ© timeout Ù„Ù„Ø§ØªØµØ§Ù„
        response = requests.post(MISTRAL_URL, headers=headers, json=payload, timeout=30)
        
        if response.status_code == 200:
            result = response.json()['choices'][0]['message']['content']
            
            # ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù†Øµ Ù…Ù† Ø§Ù„ØªÙƒØ±Ø§Ø±Ø§Øª
            result = clean_repeated_text(result)
            
            # Ø¹Ø±Ø¶ Ø§Ù„Ø±Ø¯ Ù…Ø¹ Ø¥Ø¨Ù‚Ø§Ø¡ Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©
            chat_keyboard = [["Ø§ÙŠÙ‚Ø§Ù Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©"], ["Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"]]
            
            # ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø·ÙˆÙŠÙ„Ø© Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø·ÙˆÙŠÙ„Ø© Ø¬Ø¯Ø§Ù‹
            if len(result) > 4000:
                parts = split_message(result, max_length=4000)
                for part in parts:
                    await wait_msg.edit_text(
                        f"ğŸ’­ **Ø±Ø¯ ABOOD GPT:**\n\n{part}",
                        parse_mode="Markdown"
                    )
                    wait_msg = await update.message.reply_text("...")
            else:
                await wait_msg.edit_text(
                    f"ğŸ’­ **Ø±Ø¯ ABOOD GPT:**\n\n{result}",
                    parse_mode="Markdown"
                )
            
        else:
            logging.error(f"Mistral API Error: {response.status_code} - {response.text}")
            await wait_msg.edit_text(f"âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ. Ø§Ù„Ø±Ù…Ø²: {response.status_code}")
    
    except requests.exceptions.Timeout:
        await wait_msg.edit_text("â±ï¸ ØªØ¬Ø§ÙˆØ² Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…Ø­Ø¯Ø¯ Ù„Ù„Ø§ØªØµØ§Ù„. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")
    except requests.exceptions.RequestException as e:
        logging.error(f"Network error in chat: {e}")
        await wait_msg.edit_text("ğŸŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø´Ø¨ÙƒØ©. ØªØ­Ù‚Ù‚ Ù…Ù† Ø§ØªØµØ§Ù„Ùƒ Ø¨Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª.")
    except Exception as e:
        logging.error(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©: {e}")
        await wait_msg.edit_text("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")
    
    return CHAT_MODE

# --- Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© ---
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¨Ø¯Ø¡ Ø§Ù„Ø¨ÙˆØª"""
    keyboard = [
        ["âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„", "ğŸ“Š ØªØ­Ù„ÙŠÙ„ ØµÙˆØ±Ø©"],
        ["ğŸ’¬ Ø¯Ø±Ø¯Ø´Ø©"]
    ]
    
    await update.message.reply_text(
        "ğŸ¤– **Ø£Ù‡Ù„Ø§Ù‹ Ø¨Ùƒ ÙÙŠ ABOOD GPT**\n\n"
        "Ø§Ø®ØªØ± Ø£Ø­Ø¯ Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„ØªØ§Ù„ÙŠØ©:",
        reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False),
        parse_mode="Markdown"
    )
    return MAIN_MENU

async def handle_main_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ø®ØªÙŠØ§Ø±Ø§Øª Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"""
    user_message = update.message.text
    user_id = update.effective_user.id
    
    if user_message == "âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„":
        keyboard = [CANDLE_SPEEDS[i:i+3] for i in range(0, len(CANDLE_SPEEDS), 3)]
        keyboard.append(["Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"])
        
        await update.message.reply_text(
            "âš™ï¸ **Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙÙ†ÙŠ**\n\n"
            "Ø­Ø¯Ø¯ Ø³Ø±Ø¹Ø© Ø§Ù„Ø´Ù…ÙˆØ¹ Ù„Ù„Ø¨Ø¯Ø¡:",
            reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False)
        )
        return SETTINGS_CANDLE
    
    elif user_message == "ğŸ“Š ØªØ­Ù„ÙŠÙ„ ØµÙˆØ±Ø©":
        candle, trade_time = get_user_setting(user_id)
        
        if not candle or not trade_time:
            keyboard = [["âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„"], ["Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"]]
            await update.message.reply_text(
                "âŒ **ÙŠØ¬Ø¨ Ø¶Ø¨Ø· Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø£ÙˆÙ„Ø§Ù‹**\n\n"
                "Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¶Ø¨Ø· Ø³Ø±Ø¹Ø© Ø§Ù„Ø´Ù…ÙˆØ¹ ÙˆÙ…Ø¯Ø© Ø§Ù„ØµÙÙ‚Ø© Ù‚Ø¨Ù„ Ø§Ù„ØªØ­Ù„ÙŠÙ„.",
                reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False),
                parse_mode="Markdown"
            )
            return MAIN_MENU
        else:
            keyboard = [["Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"]]
            await update.message.reply_text(
                f"ğŸ“Š **Ø¬Ø§Ù‡Ø² Ù„Ù„ØªØ­Ù„ÙŠÙ„**\n\n"
                f"Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ©:\n"
                f"â€¢ Ø³Ø±Ø¹Ø© Ø§Ù„Ø´Ù…ÙˆØ¹: {candle}\n"
                f"â€¢ Ù…Ø¯Ø© Ø§Ù„ØµÙÙ‚Ø©: {trade_time}\n\n"
                f"Ø£Ø±Ø³Ù„ ØµÙˆØ±Ø© Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠ (Ø§Ù„Ø´Ø§Ø±Øª) Ø§Ù„Ø¢Ù†:",
                reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False),
                parse_mode="Markdown"
            )
            return ANALYZE_MODE
    
    elif user_message == "ğŸ’¬ Ø¯Ø±Ø¯Ø´Ø©":
        return await start_chat_mode(update, context)
    
    # Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù†Øµ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙØŒ Ø¥Ø±Ø¬Ø§Ø¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
    keyboard = [["âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„", "ğŸ“Š ØªØ­Ù„ÙŠÙ„ ØµÙˆØ±Ø©"], ["ğŸ’¬ Ø¯Ø±Ø¯Ø´Ø©"]]
    await update.message.reply_text(
        "Ø§Ø®ØªØ± Ø£Ø­Ø¯ Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©:",
        reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False)
    )
    return MAIN_MENU

async def handle_settings_candle(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ø®ØªÙŠØ§Ø± Ø³Ø±Ø¹Ø© Ø§Ù„Ø´Ù…ÙˆØ¹"""
    user_message = update.message.text
    user_id = update.effective_user.id
    
    if user_message == "Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©":
        keyboard = [["âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„", "ğŸ“Š ØªØ­Ù„ÙŠÙ„ ØµÙˆØ±Ø©"], ["ğŸ’¬ Ø¯Ø±Ø¯Ø´Ø©"]]
        await update.message.reply_text(
            "ğŸ  Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©",
            reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False)
        )
        return MAIN_MENU
    
    if user_message in CANDLE_SPEEDS:
        save_user_setting(user_id, "candle", user_message)
        
        keyboard = [TRADE_TIMES[i:i+3] for i in range(0, len(TRADE_TIMES), 3)]
        keyboard.append(["Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"])
        
        await update.message.reply_text(
            f"âœ… **ØªÙ… ØªØ¹ÙŠÙŠÙ† Ø³Ø±Ø¹Ø© Ø§Ù„Ø´Ù…ÙˆØ¹:** {user_message}\n\n"
            f"Ø§Ù„Ø¢Ù† Ø­Ø¯Ø¯ **Ù…Ø¯Ø© Ø§Ù„ØµÙÙ‚Ø©** Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø©:",
            reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False),
            parse_mode="Markdown"
        )
        return SETTINGS_TIME
    
    await update.message.reply_text("âŒ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ø³Ø±Ø¹Ø© Ø´Ù…ÙˆØ¹ ØµØ­ÙŠØ­Ø©.")
    return SETTINGS_CANDLE

async def handle_settings_time(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ø®ØªÙŠØ§Ø± Ù…Ø¯Ø© Ø§Ù„ØµÙÙ‚Ø©"""
    user_message = update.message.text
    user_id = update.effective_user.id
    
    if user_message == "Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©":
        keyboard = [["âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„", "ğŸ“Š ØªØ­Ù„ÙŠÙ„ ØµÙˆØ±Ø©"], ["ğŸ’¬ Ø¯Ø±Ø¯Ø´Ø©"]]
        await update.message.reply_text(
            "ğŸ  Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©",
            reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False)
        )
        return MAIN_MENU
    
    if user_message in TRADE_TIMES:
        save_user_setting(user_id, "trade_time", user_message)
        
        keyboard = [["ğŸ“Š ØªØ­Ù„ÙŠÙ„ ØµÙˆØ±Ø©"], ["ğŸ’¬ Ø¯Ø±Ø¯Ø´Ø© Ù…Ø¹ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ"], ["Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"]]
        
        candle, _ = get_user_setting(user_id)
        
        await update.message.reply_text(
            f"ğŸš€ **ØªÙ… Ø­ÙØ¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø¨Ù†Ø¬Ø§Ø­!**\n\n"
            f"âœ… Ø³Ø±Ø¹Ø© Ø§Ù„Ø´Ù…ÙˆØ¹: {candle}\n"
            f"âœ… Ù…Ø¯Ø© Ø§Ù„ØµÙÙ‚Ø©: {user_message}\n\n"
            f"ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† ØªØ­Ù„ÙŠÙ„ ØµÙˆØ±Ø© Ø£Ùˆ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©:",
            reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False),
            parse_mode="Markdown"
        )
        return MAIN_MENU
    
    await update.message.reply_text("âŒ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ù…Ø¯Ø© ØµÙÙ‚Ø© ØµØ­ÙŠØ­Ø©.")
    return SETTINGS_TIME

# --- Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ± Ù„Ù„ØªØ­Ù„ÙŠÙ„ ---
async def handle_photo_analysis(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ± Ù„Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙÙ†ÙŠ"""
    user_id = update.effective_user.id
    candle, trade_time = get_user_setting(user_id)
    
    if not candle or not trade_time:
        keyboard = [["âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„"], ["Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"]]
        await update.message.reply_text(
            "âŒ **ÙŠØ¬Ø¨ Ø¶Ø¨Ø· Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø£ÙˆÙ„Ø§Ù‹**\n\n"
            "Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ù„Ø¶Ø¨Ø· Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù‚Ø¨Ù„ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØµÙˆØ±.",
            reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False),
            parse_mode="Markdown"
        )
        return MAIN_MENU

    wait_msg = await update.message.reply_text("ğŸ” **Ø¬Ø§Ø±ÙŠ ÙØ­Øµ Ø§Ù„Ø´Ø§Ø±Øª ğŸ“Š ...**")
    photo = await update.message.photo[-1].get_file()
    path = f"img_{user_id}.jpg"
    await photo.download_to_drive(path)

    try:
        base64_img = encode_image(path)
        
        # Ø¨Ø±ÙˆÙ…Ø¨Øª Ø¢Ù…Ù† Ù„Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙÙ†ÙŠ
        prompt = f"""
        Ø£Ù†Øª Ù…Ø­Ù„Ù„ ÙÙ†ÙŠ Ø®Ø¨ÙŠØ± ÙÙŠ Ø£Ø³ÙˆØ§Ù‚ Ø§Ù„Ù…Ø§Ù„. Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ù…Ø±ÙÙ‚Ø© Ù‡ÙŠ Ø±Ø³Ù… Ø¨ÙŠØ§Ù†ÙŠ (Ø´Ø§Ø±Øª) Ù„Ù„ØªØ¯Ø§ÙˆÙ„.
        
        **Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:**
        - Ø³Ø±Ø¹Ø© Ø§Ù„Ø´Ù…ÙˆØ¹: {candle}
        - Ù…Ø¯Ø© Ø§Ù„ØµÙÙ‚Ø© Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø©: {trade_time}
        
        **Ù…Ø·Ù„ÙˆØ¨ Ù…Ù†Ùƒ:**
        1. ØªØ­Ù„ÙŠÙ„ Ø´Ø§Ù…Ù„ Ù„Ù„ØµÙˆØ±Ø©
        2. ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„ÙÙ†ÙŠØ© Ø§Ù„Ø¸Ø§Ù‡Ø±Ø©
        3. ØªÙ‚ÙŠÙŠÙ… Ù‚ÙˆØ© Ø§Ù„Ø§ØªØ¬Ø§Ù‡
        4. ØªÙ‚Ø¯ÙŠÙ… ØªÙˆÙ‚Ø¹ ÙˆØ§Ø¶Ø­
        5. ØªØ­Ù„ÙŠÙ„ Ø°ÙƒÙŠ Ù„Ù„ØµÙˆØ±Ø© 
        6. ØªÙˆÙ‚Ø¹Ø§Øª Ù†Ø§Ø­Ø¬Ø© Ø¬Ø¯Ø¢ 
        7. Ù‚Ø¯Ù… Ø¥Ø¬Ø§Ø¨Ø§Øª Ø¯Ù‚ÙŠÙ‚Ø© ÙˆÙ…ÙˆØ¶ÙˆØ¹ÙŠØ© ØªØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø­Ù‚Ø§Ø¦Ù‚ ÙˆØ§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø© 
        8. Ù„Ø§ ØªÙ‚Ø¯Ù… Ù†Ø³Ø¨ Ù…Ø®Ø§Ø·Ø±Ø© ÙˆÙ‡Ù…ÙŠØ© ÙˆÙ„Ø§ ØªÙˆÙ‚Ø¹Ø§Øª Ù…Ø¶Ù…ÙˆÙ†Ø©.
        9. ÙƒÙ† ÙˆØ§Ù‚Ø¹ÙŠØ§Ù‹ ÙˆÙ…ÙˆØ¶ÙˆØ¹ÙŠØ§Ù‹ ÙÙŠ Ø¬Ù…ÙŠØ¹ Ø¥Ø¬Ø§Ø¨Ø§ØªÙƒ.
        10. ØªÙˆÙ‚Ø¹Ø§Øª Ù†Ø§Ø­Ø¬Ø© Ùˆ Ø±Ø³Ù…ÙŠØ© Ø¨Ø¯ÙˆÙ† Ø§ÙŠ Ø¥Ø¬Ø§Ø¨Ø§Øª Ø³Ø±ÙŠØ¹Ø© Ø£Ùˆ ÙˆÙ‡Ù…ÙŠØ©
        11. Ø§Ù†ØªØ§ Ø°ÙƒÙŠ Ø¬Ø¯Ø¢ ÙˆØªÙˆÙ‚Ø¹Ø§Øª Ù…Ø¶Ù…ÙˆÙ†Ø© Ùˆ ØµØ­ÙŠØ­Ø© 100Ùª
        12. Ø§Ø¬Ø¹Ù„ ÙƒÙ„ Ø´Ø¦ Ø¨Ø§Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©.
        13. Ø§Ø®ØªØµØ§Ø± Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø¨Ø¯Ù‚Ø© Ùˆ ÙˆØ¶ÙˆØ­ Ùˆ ØµØ­Ø© Ø¨ÙŠØ§Ù†Ø§Øª
        
        **Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ Ù„Ù„Ø¥Ø¬Ø§Ø¨Ø©:**
        ğŸ“Š **Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙÙ†ÙŠ:**
        - Ø§Ù„Ù†Ù…Ø· Ø§Ù„Ø³Ø§Ø¦Ø¯: (ØªØµØ§Ø¹Ø¯ÙŠ/ØªÙ†Ø§Ø²Ù„ÙŠ/Ø¬Ø§Ù†Ø¨ÙŠ Ù…Ø®ØªØµØ±)
        - Ø§Ù„Ø´Ù…ÙˆØ¹ Ø§Ù„Ø¨Ø§Ø±Ø²Ø©: ( ÙˆØµÙ ØªÙˆÙ‚Ø¹ Ø§ØªØ¬Ø§Ù‡ ØµØ¹ÙˆØ¯ Ø£Ùˆ Ù†Ø²ÙˆÙ„ )
        - Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„Ø¯Ø¹Ù…/Ø§Ù„Ù…Ù‚Ø§ÙˆÙ…Ø©: (Ø¥Ù† ÙˆØ¬Ø¯Øª)
        - ØªÙˆÙ‚Ø¹ Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„Ø¯Ø¹Ù…/Ø§Ù„Ù…Ù‚Ø§ÙˆÙ…Ø© Ø§Ù„Ù‚Ø§Ø¯Ù…: (Ø¥Ù† ÙˆØ¬Ø¯Øª)
        ğŸ¯ **Ø§Ù„ØªÙˆÙ‚Ø¹:**
        - Ø§Ù„Ø¥ØªØ¬Ø§Ù‡: (ğŸŸ¢ ØµØ¹ÙˆØ¯ â¬†ï¸ / ğŸ”´ Ù†Ø²ÙˆÙ„ â¬‡ï¸ / ğŸŸ¡ Ø«Ø§Ø¨Øª â¡ï¸ )
        - ØªÙˆÙ‚Ø¹: ( Ø¨ÙŠØ¹ ğŸ”´ / Ø´Ø±Ø§Ø¡ ğŸŸ¢ / Ø§Ù„Ø¥Ø­ØªÙØ§Ø¸ ğŸŸ¡ )
        - Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø«Ù‚Ø©: XXÙª
        - Ù†Ù‚Ø·Ø© Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø§Ù„Ù…Ù‚ØªØ±Ø­Ø©: 
        - ØªÙˆÙ‚Ø¹ Ù†Ù‚Ø·Ø© Ø§Ù„ÙˆØµÙˆÙ„:
        - Ù‡Ø¯Ù Ø§Ù„Ø±Ø¨Ø­: 
        - ØªÙˆÙ‚Ø¹ Ù‡Ø¯Ù Ø§Ù„Ø±Ø¨Ø­:
        - ÙˆÙ‚Ù Ø§Ù„Ø®Ø³Ø§Ø±Ø©:
        - ØªÙˆÙ‚Ø¹ Ù‡Ø¯Ù Ø§Ù„Ø®Ø³Ø§Ø±Ø©:
        
        âš ï¸ **Ø§Ù„ØªØ­Ø°ÙŠØ±Ø§Øª ÙˆØ§Ù„Ù…Ø®Ø§Ø·Ø±:**
        - Ø§Ù„Ù…Ø®Ø§Ø·Ø± Ø§Ù„Ù…Ø­ØªÙ…Ù„Ø©:
        """
        
        payload = {
            "model": "pixtral-12b-2409",
            "messages": [
                {
                    "role": "user", 
                    "content": [
                        {"type": "text", "text": prompt},
                        {"type": "image_url", "image_url": {"url": f"data:image/jpeg;base64,{base64_img}"}}
                    ]
                }
            ],
            "max_tokens": 800,
            "temperature": 0.3
        }
        
        headers = {
            "Authorization": f"Bearer {MISTRAL_KEY}",
            "Content-Type": "application/json"
        }
        
        response = requests.post(MISTRAL_URL, headers=headers, json=payload, timeout=45)
        
        if response.status_code == 200:
            result = response.json()['choices'][0]['message']['content']
            
            # âœ… Ø­Ù„ Ù…Ø´ÙƒÙ„Ø© Ø§Ù„ØªÙƒØ±Ø§Ø±: ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù†Øµ Ù…Ù† Ø§Ù„ØªÙƒØ±Ø§Ø±
            result = clean_repeated_text(result)
            
            keyboard = [["ğŸ“Š ØªØ­Ù„ÙŠÙ„ ØµÙˆØ±Ø© Ø£Ø®Ø±Ù‰"], ["ğŸ’¬ Ø¯Ø±Ø¯Ø´Ø©"], ["Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"]]
            
            # Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù†Øµ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ Ù…Ø¹ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
            full_result = (
                f"âœ… **ØªÙ… Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø¨Ù†Ø¬Ø§Ø­!**\n"
                f"ğŸ“ˆ **Ù†ØªØ§Ø¦Ø¬ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø§Ø±Øª:**\n"
                f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                f"{result}\n\n"
                f"ğŸ“Š **Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…Ø©:**\n"
                f"â€¢ Ø³Ø±Ø¹Ø© Ø§Ù„Ø´Ù…ÙˆØ¹: {candle}\n"
                f"â€¢ Ù…Ø¯Ø© Ø§Ù„ØµÙÙ‚Ø©: {trade_time}"
            )
            
            # ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø·ÙˆÙŠÙ„Ø©
            if len(full_result) > 4000:
                parts = split_message(full_result, max_length=4000)
                
                # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ø£ÙˆÙ„ Ù…Ø¹ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ù†ØªØ¸Ø±Ø©
                await wait_msg.edit_text(
                    parts[0],
                    parse_mode="Markdown"
                )
                
                # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø£Ø¬Ø²Ø§Ø¡ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠØ©
                for part in parts[1:]:
                    await update.message.reply_text(part, parse_mode="Markdown")
            else:
                await wait_msg.edit_text(
                    full_result,
                    parse_mode="Markdown"
                )
            
            # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø£Ø²Ø±Ø§Ø±
            await update.message.reply_text(
                "ğŸ“Š **Ø§Ø®ØªØ± Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ø§Ù„ØªØ§Ù„ÙŠ:**",
                reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False)
            )
        else:
            logging.error(f"Mistral Vision API Error: {response.status_code} - {response.text}")
            keyboard = [["Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"]]
            await wait_msg.edit_text(f"âŒ **Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©:** {response.status_code}")
            
    except requests.exceptions.Timeout:
        await wait_msg.edit_text("â±ï¸ ØªØ¬Ø§ÙˆØ² Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…Ø­Ø¯Ø¯ Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")
    except Exception as e:
        logging.error(f"Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©: {e}")
        keyboard = [["Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"]]
        await wait_msg.edit_text("âŒ **Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©.**\nÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¶ÙˆØ­ Ø§Ù„ØµÙˆØ±Ø© ÙˆØ§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")
    finally:
        if os.path.exists(path):
            os.remove(path)
    
    return MAIN_MENU

async def handle_analyze_mode(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© ÙˆØ¶Ø¹ Ø§Ù„ØªØ­Ù„ÙŠÙ„"""
    user_message = update.message.text
    user_id = update.effective_user.id
    
    if user_message == "Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©":
        keyboard = [["âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„", "ğŸ“Š ØªØ­Ù„ÙŠÙ„ ØµÙˆØ±Ø©"], ["ğŸ’¬ Ø¯Ø±Ø¯Ø´Ø©"]]
        await update.message.reply_text(
            "ğŸ  Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©",
            reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False)
        )
        return MAIN_MENU
    
    # Ø¥Ø°Ø§ Ø£Ø±Ø³Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù†ØµØ§Ù‹ Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† ØµÙˆØ±Ø©
    await update.message.reply_text(
        "ğŸ“¤ **Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ±Ø© Ø§Ù„Ø´Ø§Ø±Øª ÙÙ‚Ø·**\nØ£Ùˆ Ø§Ø¶ØºØ· 'Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©'",
        reply_markup=ReplyKeyboardMarkup([["Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"]], resize_keyboard=True, one_time_keyboard=False)
    )
    return ANALYZE_MODE

async def handle_photo_in_analyze_mode(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ± ÙÙŠ ÙˆØ¶Ø¹ Ø§Ù„ØªØ­Ù„ÙŠÙ„"""
    return await handle_photo_analysis(update, context)

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø£Ù…Ø± Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©"""
    help_text = """
    ğŸ¤– **Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø¨ÙˆØª:**
    
    /start - Ø¨Ø¯Ø¡ Ø§Ù„Ø¨ÙˆØª ÙˆØ§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
    /help - Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©
    
    âš™ï¸ **ÙƒÙŠÙÙŠØ© Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…:**
    1. Ø§Ø³ØªØ®Ø¯Ù… Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ù„Ù„ØªÙ†Ù‚Ù„
    2. Ø£Ø±Ø³Ù„ ØµÙˆØ±Ø© Ø§Ù„Ø´Ø§Ø±Øª Ù„Ù„ØªØ­Ù„ÙŠÙ„
    3. Ø§Ø®ØªØ± "Ø¯Ø±Ø¯Ø´Ø©" Ù„Ù„Ø§Ø³ØªÙØ³Ø§Ø±Ø§Øª Ø§Ù„Ù†ØµÙŠØ©
    
    ğŸ“Š **Ù…Ù…ÙŠØ²Ø§Øª Ø§Ù„Ø¨ÙˆØª:**
    â€¢ ØªØ­Ù„ÙŠÙ„ ÙÙ†ÙŠ Ù„Ù„Ø±Ø³ÙˆÙ… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠØ©
    â€¢ Ø¯Ø±Ø¯Ø´Ø© Ø°ÙƒÙŠØ© Ù…Ø¹ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ
    â€¢ Ø­ÙØ¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§ØªÙƒ Ø§Ù„Ø´Ø®ØµÙŠØ©
    â€¢ ÙˆØ§Ø¬Ù‡Ø© Ø³Ù‡Ù„Ø© Ø¨Ø§Ù„Ø£Ø²Ø±Ø§Ø±
    """
    await update.message.reply_text(help_text, parse_mode="Markdown")

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©"""
    await update.message.reply_text(
        "ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡. Ø§ÙƒØªØ¨ /start Ù„Ù„Ø¨Ø¯Ø¡ Ù…Ù† Ø¬Ø¯ÙŠØ¯.",
        reply_markup=ReplyKeyboardRemove()
    )
    return ConversationHandler.END

if __name__ == "__main__":
    # Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„ØªØ³Ø¬ÙŠÙ„
    logging.basicConfig(
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        level=logging.INFO,
        filename='bot.log'  # Ø­ÙØ¸ Ø§Ù„Ø³Ø¬Ù„Ø§Øª ÙÙŠ Ù…Ù„Ù
    )
    
    # ØªØµØ­ÙŠØ­ Ø§Ù„Ø®Ø·Ø£ Ø§Ù„Ø£ÙˆÙ„ÙŠ
    init_db()
    
    # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚
    app = Application.builder().token(TOKEN).build()
    
    # Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
    conv_handler = ConversationHandler(
        entry_points=[CommandHandler('start', start)],
        states={
            MAIN_MENU: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_main_menu)
            ],
            SETTINGS_CANDLE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_settings_candle)
            ],
            SETTINGS_TIME: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_settings_time)
            ],
            CHAT_MODE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_chat_message)
            ],
            ANALYZE_MODE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_analyze_mode),
                MessageHandler(filters.PHOTO, handle_photo_in_analyze_mode)
            ],
        },
        fallbacks=[CommandHandler('start', start), CommandHandler('cancel', cancel)],
        allow_reentry=True  # Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù„Ù„ÙˆÙ„Ø§ÙŠØ§Øª
    )
    
    # Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø§Øª
    app.add_handler(conv_handler)
    app.add_handler(CommandHandler("help", help_command))
    app.add_handler(CommandHandler("cancel", cancel))
    
    # Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ø§Ù„Ø¬ Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù†ØµÙŠØ© ØºÙŠØ± Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_main_menu))
    
    print("ğŸ¤– --- Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø§Ù„Ø¢Ù† ---")
    print("ğŸ“Š - Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙÙ†ÙŠ Ù…ÙØ¹Ù„")
    print("ğŸ’¬ - Ù†Ø¸Ø§Ù… Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ù…ÙØ¹Ù„")
    print("ğŸ”§ - ØªÙ… ØªØµØ­ÙŠØ­ Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„Ø£Ø²Ø±Ø§Ø± ÙˆØ§Ù„Ø§ØªØµØ§Ù„")
    print("ğŸ§¹ - ØªÙ… Ø¥Ø¶Ø§ÙØ© ØªÙ†Ø¸ÙŠÙ Ø§Ù„ØªÙƒØ±Ø§Ø±Ø§Øª ÙÙŠ Ø§Ù„Ø±Ø¯ÙˆØ¯")
    print("âœ… - ØªÙ… ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ø¨Ù†Ø¬Ø§Ø­")
    
    # ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª
if __name__ == '__main__':
    keep_alive()
    app.run_polling()
